This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
src/
  lib.rs
  shader.wgsl
tests/
  test_core.py
www/
  index.html
  index.js
.gitignore
Cargo.toml
LICENSE
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/shader.wgsl">
// ========================================================================
// 6D Quantum SLAM Compute Shader
// ========================================================================

// ------------------------------------------------------------------------
// Data Structures
// ------------------------------------------------------------------------

struct Uniforms {
    resolution: vec2<f32>,   // 画面解像度 (x, y)
    time: f32,               // 経過時間 t
    wave_number: f32,        // 波数 k (不確定性の逆数)
    decay_factor: f32,       // 距離減衰率
    feedback_strength: f32,  // 時間フィードバック強度 (0.0 ~ 1.0)
    num_landmarks: u32,      // ランドマーク数
    camera_pos: vec2<f32>,   // (デバッグ用) 真のカメラ位置
};

struct Landmark {
    position: vec2<f32>,     // ランドマークの空間位置
    observed_dist: f32,      // カメラから観測された距離
    confidence: f32,         // 信頼度 (量子の振幅に対応)
    phase_offset: f32,       // 時間的位相ズレ
};

// ------------------------------------------------------------------------
// Bindings
// ------------------------------------------------------------------------

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> landmarks: array<Landmark>;

// Ping-Pong Buffering for Temporal Feedback
// Texture A: 前フレームの結果 (読み込み用)
// Texture B: 今回の書き込み先
@group(0) @binding(2) var prev_frame_texture: texture_2d<f32>;
@group(0) @binding(3) var output_texture: texture_storage_2d<rgba8unorm, write>;

// ------------------------------------------------------------------------
// Math Helpers (Complex Numbers)
// ------------------------------------------------------------------------

fn complex_add(a: vec2<f32>, b: vec2<f32>) -> vec2<f32> {
    return a + b;
}

fn complex_mul_scalar(a: vec2<f32>, s: f32) -> vec2<f32> {
    return a * s;
}

// 複素指数関数: e^{i * theta} = cos(theta) + i*sin(theta)
fn complex_exp(theta: f32) -> vec2<f32> {
    return vec2<f32>(cos(theta), sin(theta));
}

// 確率密度: |z|^2
fn probability_density(z: vec2<f32>) -> f32 {
    return z.x * z.x + z.y * z.y;
}

// ------------------------------------------------------------------------
// Main Kernel
// ------------------------------------------------------------------------

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let width = u32(uniforms.resolution.x);
    let height = u32(uniforms.resolution.y);

    if (global_id.x >= width || global_id.y >= height) {
        return;
    }

    // ピクセル座標を UV空間 (-1.0 ~ 1.0) に正規化
    // アスペクト比を維持
    let aspect = uniforms.resolution.x / uniforms.resolution.y;
    let uv = (vec2<f32>(global_id.xy) / uniforms.resolution) * 2.0 - 1.0;
    let pos_space = vec2<f32>(uv.x * aspect, uv.y);

    // ------------------------------------------------------------
    // Step 1: 波動関数の重ね合わせ (Quantum Superposition)
    // ------------------------------------------------------------
    // 全てのランドマークからの「逆観測波」を複素加算する
    var psi: vec2<f32> = vec2<f32>(0.0, 0.0);

    for (var i = 0u; i < uniforms.num_landmarks; i = i + 1u) {
        let lm = landmarks[i];

        // 仮説: もしカメラが「ここ(pos_space)」にいるとしたら、距離は？
        let hypo_dist = distance(pos_space, lm.position);

        // 残差 (Residual): 仮説距離 - 観測距離
        // これが 0 に近い場所ほど、位相が揃う (Constructive Interference)
        let residual = hypo_dist - lm.observed_dist;

        // 位相計算:
        // k * residual + temporal_phase
        // 時間項を入れることで「ゆらぎ」や「6次元的な回転」を表現
        let phase = uniforms.wave_number * residual + lm.phase_offset;

        // 振幅計算:
        // 距離が離れるほど不確かさが増す (減衰)
        let amplitude = lm.confidence * exp(-uniforms.decay_factor * abs(residual));

        // 波動関数への寄与
        let wave = complex_mul_scalar(complex_exp(phase), amplitude);
        psi = complex_add(psi, wave);
    }

    // ------------------------------------------------------------
    // Step 2: 確率密度の収縮 (Wavefunction Collapse)
    // ------------------------------------------------------------
    // 現在のフレームにおける瞬間的な存在確率
    let current_prob = probability_density(psi);

    // ------------------------------------------------------------
    // Step 3: 時間的フィードバック (Tenet Feedback)
    // ------------------------------------------------------------
    // 前のフレームの確率場をサンプリング
    // textureLoad は整数座標(ivec2)を使う
    let prev_color = textureLoad(prev_frame_texture, vec2<i32>(global_id.xy), 0);
    // 直前の確率は Gチャンネル に入っていると仮定 (Sci-Fi Green)
    let prev_prob = prev_color.g; 

    // 過去と現在の融合 (Incoherent mixing)
    // alpha = feedback_strength
    // これにより、確率の「軌跡」が描かれ、過去の情報が現在を拘束する
    let mixed_prob = mix(current_prob, prev_prob, uniforms.feedback_strength);

    // ------------------------------------------------------------
    // Step 4: 可視化レンダリング
    // ------------------------------------------------------------
    // 確率が高いほど明るく発光
    // 真の解周辺は強め合い(干渉)、誤った解は弱め合う
    
    // R: 瞬間的な位相の干渉 (赤くチラつくノイズ成分)
    let r = current_prob * 0.1;
    
    // G: 時間積分された確かな存在確率 (量子SLAMの解)
    let g = mixed_prob * 2.0; 
    
    // B: ランドマーク近傍のポテンシャル可視化
    let b = mixed_prob * 0.5 + 0.1 * sin(uniforms.time * 2.0);

    // 真のカメラ位置を表示（デバッグ用：白い点）
    let dist_to_cam = distance(pos_space, uniforms.camera_pos);
    let cam_marker = 1.0 - smoothstep(0.02, 0.03, dist_to_cam);

    let final_color = vec4<f32>(
        r + cam_marker, 
        g + cam_marker, 
        b + cam_marker, 
        1.0
    );

    textureStore(output_texture, global_id.xy, final_color);
}
</file>

<file path="tests/test_core.py">
import pytest
import math

# プロジェクト名(Cargo.tomlのlib name)に合わせてインポート
import inverse_observation_induced_probability_field_interference


def test_constructive_interference():
    """
    真のカメラ位置において、確率密度（干渉）が最大化することを確認する。
    """
    # 1. Initialize Simulation
    wave_number = 10.0
    sim = inverse_observation_induced_probability_field_interference.PyQuantumSlam(
        wave_number
    )

    # 2. Add Landmarks (e.g., Triangle formation)
    sim.add_landmark(0.0, 10.0)
    sim.add_landmark(-10.0, -10.0)
    sim.add_landmark(10.0, -10.0)

    # 3. Simulate Observation
    # True Camera is at (0,0)
    true_x, true_y = 0.0, 0.0
    sim.update_observation(true_x, true_y)

    # 4. Check Probability Field
    prob_at_center = sim.get_probability(0.0, 0.0)
    prob_at_off = sim.get_probability(5.0, 5.0)  # Wrong location

    print(f"Prob(Center): {prob_at_center}")
    print(f"Prob(Offset): {prob_at_off}")

    # 干渉により、中心（真の値）の方が確率が高いはず
    assert prob_at_center > prob_at_off, "Constructive interference failed!"


def test_interference_resolution():
    """
    波数(k)を上げると、ピークが鋭くなる（不確定性が減る）ことを確認
    """
    # Low K vs High K
    sim_low_k = (
        inverse_observation_induced_probability_field_interference.PyQuantumSlam(1.0)
    )
    sim_high_k = (
        inverse_observation_induced_probability_field_interference.PyQuantumSlam(50.0)
    )

    # 【修正ポイント】
    # 干渉（Interference）を発生させるためには、最低でも2つの波源（ランドマーク）が必要です。
    # 1つだけだと、単なる距離減衰（エンベロープ）しか観測されず、波数の影響が振幅に出ません。
    # 対向する位置に2つ配置することで、中心からずれた時にお互いの位相が打ち消し合う効果を確認します。

    landmarks = [(10.0, 0.0), (-10.0, 0.0)]

    for x, y in landmarks:
        sim_low_k.add_landmark(x, y)
        sim_high_k.add_landmark(x, y)

    # 真のカメラ位置(0,0)で観測を更新
    sim_low_k.update_observation(0.0, 0.0)
    sim_high_k.update_observation(0.0, 0.0)

    # 少しだけズレた場所
    offset = 0.1

    # Low K: ズレても位相差が小さいため、強め合いが続き、確率はあまり下がらない (Broad peak)
    prob_low_center = sim_low_k.get_probability(0.0, 0.0)
    prob_low_offset = sim_low_k.get_probability(offset, 0.0)
    decay_low = prob_low_center - prob_low_offset

    # High K: ズレると位相差が大きくなり、破壊的干渉が起きて確率は急激に下がる (Sharp peak)
    prob_high_center = sim_high_k.get_probability(0.0, 0.0)
    prob_high_offset = sim_high_k.get_probability(offset, 0.0)
    decay_high = prob_high_center - prob_high_offset

    print(
        f"\n[Low K] Center: {prob_low_center:.4f}, Offset: {prob_low_offset:.4f}, Decay: {decay_low:.4f}"
    )
    print(
        f"[High K] Center: {prob_high_center:.4f}, Offset: {prob_high_offset:.4f}, Decay: {decay_high:.4f}"
    )

    # High Kの方が、少しのズレで大きく値が下がる（減衰量が大きい）はず
    assert decay_high > decay_low, (
        f"Quantum precision check failed! High K should decay faster. (L:{decay_low} vs H:{decay_high})"
    )


if __name__ == "__main__":
    test_constructive_interference()
    test_interference_resolution()
    print("All Quantum Tests Passed.")
</file>

<file path=".gitignore">
# ========================
# Rust / Cargo
# ========================
# ビルド生成物（巨大なので絶対にコミットしない）
/target/

# バックアップファイルなど
**/*.rs.bk

# Cargo.lock はライブラリ開発なら無視することもありますが、
# 今回はアプリケーション/PoCとしての再現性を重視するためコミットします。
# (無視したい場合は下の行の # を外してください)
# Cargo.lock

# ========================
# Python
# ========================
# バイトコード
__pycache__/
*.py[cod]
*$py.class

# C拡張モジュール (MaturinでビルドされたRustライブラリ本体)
*.so
*.pyd
*.dylib

# 配布用ビルドアーティファクト
dist/
build/
*.egg-info/

# 仮想環境 (uv venv)
.venv/
venv/
env/
ENV/

# テスト・型チェックキャッシュ
.pytest_cache/
.mypy_cache/

# ========================
# WebAssembly / Frontend
# ========================
# wasm-pack によって自動生成されるファイル群
# (ソースコードからいつでも再生成できるためコミット不要)
www/pkg/

# npm を使うようになった場合の依存ライブラリ
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ========================
# OS / IDE / Editors
# ========================
# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db

# VS Code
.vscode/

# IntelliJ / PyCharm
.idea/

# Vim / Emacs
*~
*.swp
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Funmatu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  # mainブランチにpushされたら実行
  push:
    branches: ["main"]
  # ブラウザから手動で実行したい時用
  workflow_dispatch:

permissions:
  contents: write # gh-pagesブランチへの書き込み権限

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Rust環境のセットアップ (キャッシュも効く現代的なAction)
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      # wasm-packのインストール
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      # ビルド実行 (Releaseモードで最適化)
      - name: Build WASM
        # ハイブリッド構成なので、Web用フラグ(--features wasm)を明示的にONにする
        run: wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm
      
      # CIサーバー上でのみ ルートと、pkg内部のgitignoreの両方を抹殺する。
      # これにより、ユーザーのローカル環境は汚さずに、生成された pkg フォルダを強制的に認識させる。
      - name: Remove .gitignore to allow deploying pkg
        run: |
          rm -f .gitignore
          rm -f www/pkg/.gitignore
      
      # Jekyll処理を無効化するファイルを作成
      - name: Create .nojekyll
        run: touch www/.nojekyll

      # GitHub Pagesへのデプロイ
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./www # このフォルダの中身を公開する
          force_orphan: true # 履歴を溜め込まず、常に最新版だけで上書きする（軽量化）

# ======================================================================================
#  [Reference] Python CI Job
#  将来的にPythonモジュールの自動テストが必要になった場合、以下のコメントを解除してjobsに追加してください。
#  (ローカルのUV環境で十分な場合は不要です)
# ======================================================================================
#   test-python:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#
#       - name: Set up Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.10'
#
#       # Python側でもRustコンパイラは必要
#       - name: Install Rust
#         uses: dtolnay/rust-toolchain@stable
#
#       - name: Install Maturin
#         run: pip install maturin
#
#       - name: Build and Test Python Module
#         # Releaseビルドでテストする場合、--release を追加してください
#         run: |
#           maturin develop --features python
#           python -c "import Inverse_Observation_Induced_Probability_Field_Interference; print(f'Test Result: {Inverse_Observation_Induced_Probability_Field_Interference.compute_metrics(1000, 1.0)}')"
</file>

<file path="www/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6D Quantum SLAM Visualization</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        h1 { margin-bottom: 0.5rem; }
        canvas { 
            border: 1px solid #333; 
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.2);
            background: black;
        }
        .controls { margin-top: 1rem; }
    </style>
</head>
<body>
    <h1>Tenet-SLAM: Quantum Interference Field</h1>
    <p>Visualizing Inverse Observation Probability with Temporal Feedback</p>
    
    <canvas id="quantum-canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button id="start-btn">Initialize WGPU Quantum Field</button>
    </div>
    
    <script type="module" src="./index.js"></script>
</body>
</html>
</file>

<file path="www/index.js">
import init, { QuantumRenderer } from './pkg/inverse_observation_induced_probability_field_interference.js';

async function run() {
    await init();
    
    const btn = document.getElementById('start-btn');
    const canvas = document.getElementById('quantum-canvas');
    
    btn.addEventListener('click', async () => {
        btn.disabled = true;
        btn.innerText = "Quantum Coherence Established";
        
        try {
            // Rust側のWGPU初期化
            const renderer = await QuantumRenderer.new("quantum-canvas");
            
            function loop() {
                renderer.update(); // 物理更新
                renderer.render(); // 描画
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
            
        } catch (e) {
            console.error(e);
            alert("WebGPU not supported or error initializing: " + e);
            btn.disabled = false;
        }
    });
}

run();
</file>

<file path="Cargo.toml">
[package]
name = "Inverse-Observation-Induced-Probability-Field-Interference"
version = "0.1.0"
edition = "2021"
authors = ["Funmatu <funmatu@gmail.com>"]
description = "A dual-runtime computation core for WebAssembly and Python, powered by Rust."

[lib]
name = "inverse_observation_induced_probability_field_interference"
crate-type = ["cdylib", "rlib"]

[features]
default = []

wasm = [
    "dep:wasm-bindgen",
    "dep:wasm-bindgen-futures",
    "dep:console_error_panic_hook",
    "dep:web-sys",
    "dep:js-sys"
]
python = ["dep:pyo3"]

[dependencies]
# --- Core Math & Utils ---
serde = { version = "1.0", features = ["derive"] }
bytemuck = { version = "1.16", features = ["derive"] }
pollster = "0.3"
rand = "0.8"

getrandom = { version = "0.2", features = ["js"] }

# --- Graphics / Compute (WGPU) ---
wgpu = "0.20"

# --- Feature: WebAssembly ---
wasm-bindgen = { version = "0.2", optional = true }
wasm-bindgen-futures = { version = "0.4", optional = true }
console_error_panic_hook = { version = "0.1", optional = true }
js-sys = { version = "0.3", optional = true }

web-sys = { version = "0.3", optional = true, features = [
    "Document",
    "Window",
    "Element",
    "HtmlCanvasElement",
    "Performance",
] }

# --- Feature: Python ---
pyo3 = { version = "0.20", features = ["extension-module"], optional = true }

# CPU並列計算用
rayon = "1.10"

[profile.release]
lto = true
opt-level = 3
codegen-units = 1
</file>

<file path="pyproject.toml">
[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[project]
name = "Inverse_Observation_Induced_Probability_Field_Interference"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dynamic = ["version"]
</file>

<file path="README.md">
# 6D Quantum Gaussian Splatting

[![CI/CD](https://github.com/Funmatu/Inverse-Observation-Induced-Probability-Field-Interference/actions/workflows/deploy.yml/badge.svg)](https://funmatu.github.io/Inverse-Observation-Induced-Probability-Field-Interference/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

![Rust](https://img.shields.io/badge/rust-%23000000.svg?style=for-the-badge&logo=rust&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)
![WebAssembly](https://img.shields.io/badge/WebAssembly-654FF0?style=for-the-badge&logo=webassembly&logoColor=white)

![WGPU](https://img.shields.io/badge/GPU-WGPU%20Compute-blueviolet?style=flat-square&logo=webgpu&logoColor=white)
![PyO3](https://img.shields.io/badge/Bindings-PyO3-blue?style=flat-square)
![Maturin](https://img.shields.io/badge/Build-Maturin-green?style=flat-square)

![Platform](https://img.shields.io/badge/platform-Web%20%7C%20Linux%20%7C%20macOS%20%7C%20Windows-lightgrey)

**A Proof of Concept for Inverse Observation-Induced Probability Field Interference.**

This project explores a novel SLAM architecture inspired by Quantum Mechanics and the concept of "Temporal Pincer Movements". Instead of filtering current observations to estimate position, we model the environment as a field of observers that project "probability waves" back into the space. The convergence of these waves (Constructive Interference) defines the agent's existence.

## 1. Theoretical Foundation

### 1.1 Inverse Observation Model
Traditional SLAM solves $P(x | z)$ (Probability of pose $x$ given measurement $z$).
We invert this: The environment consists of anchors $L_i$ that "observe" the agent. Each anchor emits a spherical probability wave $\Psi_i(x)$ based on the measured distance $d_i$.

$$
\Psi(x) = \sum_{i} A_i \cdot e^{i (k |x - L_i| - \phi_i)}
$$

* **Constructive Interference:** Where waves align, probability density $|\Psi|^2$ spikes. This is the estimated position.
* **Destructive Interference:** Elsewhere, waves cancel out, naturally suppressing noise and "ghost" solutions.

### 1.2 Feedback (Temporal Entanglement)
We introduce a 6th dimension (Time/Causality) by feeding the *past* probability field back into the *current* estimation.

$$
P_{t}(x) = (1 - \alpha)|\Psi_{t}(x)|^2 + \alpha P_{t-1}(x)
$$

This creates a "World Tube" where the agent's existence is stabilized by its own history, preventing instant tracking loss (teleportation).

## 2. Architecture

This repository uses a **Dual-Runtime Architecture** powered by Rust.

| Component | Tech Stack | Role |
|-----------|------------|------|
| **Core Physics** | Rust (CPU) | Exact math verification, unit testing. |
| **Visualization** | Rust + WGPU (Compute Shader) | Real-time interference simulation, massive parallelization. |
| **Analysis** | Python (PyO3) | Automated testing of interference properties. |
| **Web Demo** | WASM + WebGPU | Browser-based interactive visualization. |

## 3. Implementation Details

### Compute Shader (`shader.wgsl`)
The heart of the simulation. It runs on the GPU, calculating complex wave summation for every pixel in parallel.
* **Ping-Pong Buffering:** Used to read the previous frame's probability texture while writing to the current one, enabling the temporal feedback loop.
* **Complex Math:** Standard WGSL `float` operations are combined to simulate complex number arithmetic (Phase/Amplitude).

### Hybrid Rust Crate (`lib.rs`)
* **`QuantumSlamCore`:** A pure CPU implementation of the interference formula. Exposed to Python for `pytest`.
* **`QuantumRenderer`:** A WGPU wrapper handling the device, queue, and swapchain for WebAssembly.

## 4. Running the Demo

### Web (Visualization)
Requires a browser with **WebGPU** support (Chrome/Edge 113+).

1.  `wasm-pack build --target web --features wasm`
2.  Serve the `www` directory.

### Python (Verification)
1.  `maturin develop --features python`
2.  `pytest test_core.py`

## 5. Future Work: The "Temporal Pincer Movements" Algorithm
Currently, the feedback is $t-1 \to t$. The next step is to implement **Bi-directional Time Optimization**:
Using loop closures (future information) to propagate probability waves *backwards* in time ($t+k \to t$), collapsing the wave function of past uncertain states.

---
</file>

<file path="src/lib.rs">
// Rust 1.78+ と PyO3 0.20 の互換性警告をプロジェクトレベルで抑制
#![allow(non_local_definitions)]

use serde::{Serialize, Deserialize};
use bytemuck::{Pod, Zeroable};

#[cfg(feature = "wasm")]
use wasm_bindgen::prelude::*;

// ============================================================================
//  Shared Data Structures (CPU/GPU Common)
// ============================================================================

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable, Serialize, Deserialize)]
pub struct Landmark {
    pub position: [f32; 2],
    pub observed_dist: f32,
    pub confidence: f32,
    pub phase_offset: f32,
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct Uniforms {
    pub resolution: [f32; 2],
    pub time: f32,
    pub wave_number: f32,
    pub decay_factor: f32,
    pub feedback_strength: f32,
    pub num_landmarks: u32,
    pub _pad: u32, // WGSLのアライメント(8byte)調整用パディング
    pub camera_pos: [f32; 2],
}

// ============================================================================
//  1. Physics Core (Pure Rust - CPU Implementation)
// ============================================================================

pub struct QuantumSlamCore {
    pub landmarks: Vec<Landmark>,
    pub wave_number: f64,
}

impl QuantumSlamCore {
    pub fn new(wave_number: f64) -> Self {
        Self {
            landmarks: Vec::new(),
            wave_number,
        }
    }

    pub fn add_landmark(&mut self, x: f32, y: f32) {
        self.landmarks.push(Landmark {
            position: [x, y],
            observed_dist: 0.0, // Init
            confidence: 1.0,
            phase_offset: 0.0,
        });
    }

    pub fn observe(&mut self, true_cam_x: f32, true_cam_y: f32) {
        for lm in &mut self.landmarks {
            let dx = lm.position[0] - true_cam_x;
            let dy = lm.position[1] - true_cam_y;
            lm.observed_dist = (dx * dx + dy * dy).sqrt();
        }
    }

    pub fn probability_at(&self, x: f32, y: f32) -> f64 {
        let mut re_sum = 0.0;
        let mut im_sum = 0.0;

        for lm in &self.landmarks {
            let dx = x - lm.position[0];
            let dy = y - lm.position[1];
            let hypo_dist = (dx * dx + dy * dy).sqrt();
            
            let residual = hypo_dist - lm.observed_dist;
            let phase = self.wave_number as f32 * residual;
            let amp = lm.confidence * (-2.0 * residual.abs()).exp();

            re_sum += amp * phase.cos();
            im_sum += amp * phase.sin();
        }

        (re_sum * re_sum + im_sum * im_sum) as f64
    }
}

// ============================================================================
//  2. Python Bindings (PyO3)
// ============================================================================
#[cfg(feature = "python")]
use pyo3::prelude::*;

#[cfg(feature = "python")]
#[pyclass]
pub struct PyQuantumSlam {
    core: QuantumSlamCore,
}

#[cfg(feature = "python")]
#[pymethods]
impl PyQuantumSlam {
    #[new]
    fn new(wave_number: f64) -> Self {
        Self { core: QuantumSlamCore::new(wave_number) }
    }

    fn add_landmark(&mut self, x: f32, y: f32) {
        self.core.add_landmark(x, y);
    }

    fn update_observation(&mut self, cam_x: f32, cam_y: f32) {
        self.core.observe(cam_x, cam_y);
    }

    fn get_probability(&self, x: f32, y: f32) -> f64 {
        self.core.probability_at(x, y)
    }
}

#[cfg(feature = "python")]
#[pymodule]
fn inverse_observation_induced_probability_field_interference(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<PyQuantumSlam>()?;
    Ok(())
}

// ============================================================================
//  3. WGPU Renderer (WASM / Visualization)
// ============================================================================

#[cfg(feature = "wasm")]
const SHADER_SOURCE: &str = include_str!("shader.wgsl");

#[cfg(feature = "wasm")]
#[wasm_bindgen]
pub struct QuantumRenderer {
    #[wasm_bindgen(skip)]
    pub device: wgpu::Device,
    #[wasm_bindgen(skip)]
    pub queue: wgpu::Queue,
    #[wasm_bindgen(skip)]
    pub surface: wgpu::Surface<'static>,
    #[wasm_bindgen(skip)]
    pub config: wgpu::SurfaceConfiguration,
    #[wasm_bindgen(skip)]
    pub pipeline: wgpu::ComputePipeline,
    #[wasm_bindgen(skip)]
    pub bind_group_layout: wgpu::BindGroupLayout,
    
    // Double Buffering
    #[wasm_bindgen(skip)]
    pub texture_a: wgpu::Texture,
    #[wasm_bindgen(skip)]
    pub texture_a_view: wgpu::TextureView,
    #[wasm_bindgen(skip)]
    pub texture_b: wgpu::Texture,
    #[wasm_bindgen(skip)]
    pub texture_b_view: wgpu::TextureView,
    
    #[wasm_bindgen(skip)]
    pub uniform_buffer: wgpu::Buffer,
    #[wasm_bindgen(skip)]
    pub landmark_buffer: wgpu::Buffer,
    
    start_time: f64,
    frame_count: u64,
    
    landmarks: Vec<Landmark>,
    camera_pos: [f32; 2],
    
    width: u32,
    height: u32,
}

#[cfg(feature = "wasm")]
#[wasm_bindgen]
impl QuantumRenderer {
    pub async fn new(canvas_id: &str) -> Result<QuantumRenderer, JsValue> {
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document.get_element_by_id(canvas_id)
            .ok_or("Canvas not found")?
            .dyn_into::<web_sys::HtmlCanvasElement>()?;
        
        let width = canvas.width();
        let height = canvas.height();

        let instance = wgpu::Instance::default();
        
        let surface_target = wgpu::SurfaceTarget::Canvas(canvas);
        let surface = instance.create_surface(surface_target).map_err(|e| e.to_string())?;
        
        let adapter = instance.request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        }).await.ok_or("No adapter found")?;

        let (device, queue) = adapter.request_device(&wgpu::DeviceDescriptor {
            label: Some("Quantum Device"),
            required_features: wgpu::Features::empty(),
            required_limits: adapter.limits(),
        }, None).await.map_err(|e| e.to_string())?;

        let surface_caps = surface.get_capabilities(&adapter);
        let surface_format = surface_caps.formats.iter()
            .copied()
            .find(|f: &wgpu::TextureFormat| f.is_srgb())
            .unwrap_or(surface_caps.formats[0]);

        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_DST,
            format: surface_format,
            width,
            height,
            present_mode: surface_caps.present_modes[0],
            alpha_mode: surface_caps.alpha_modes[0],
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };
        surface.configure(&device, &config);

        // Ping-Pong Textures
        let texture_desc = wgpu::TextureDescriptor {
            label: Some("Probability Field"),
            size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8Unorm,
            usage: wgpu::TextureUsages::TEXTURE_BINDING 
                 | wgpu::TextureUsages::STORAGE_BINDING 
                 | wgpu::TextureUsages::COPY_SRC 
                 | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        };

        let texture_a = device.create_texture(&texture_desc);
        let texture_b = device.create_texture(&texture_desc);
        let texture_a_view = texture_a.create_view(&wgpu::TextureViewDescriptor::default());
        let texture_b_view = texture_b.create_view(&wgpu::TextureViewDescriptor::default());

        // Buffers
        let uniform_size = std::mem::size_of::<Uniforms>() as wgpu::BufferAddress;
        let uniform_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Uniform Buffer"),
            size: uniform_size,
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });

        let landmark_size = (std::mem::size_of::<Landmark>() * 100) as wgpu::BufferAddress;
        let landmark_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Landmark Buffer"),
            size: landmark_size,
            usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });

        // Pipeline
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Quantum Shader"),
            source: wgpu::ShaderSource::Wgsl(std::borrow::Cow::Borrowed(SHADER_SOURCE)),
        });

        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Compute Bind Group Layout"),
            entries: &[
                // Uniforms
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer { 
                        ty: wgpu::BufferBindingType::Uniform, 
                        has_dynamic_offset: false, 
                        min_binding_size: None 
                    },
                    count: None,
                },
                // Landmarks
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer { 
                        ty: wgpu::BufferBindingType::Storage { read_only: true }, 
                        has_dynamic_offset: false, 
                        min_binding_size: None 
                    },
                    count: None,
                },
                // Input Texture (Prev Frame)
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Texture { 
                        sample_type: wgpu::TextureSampleType::Float { filterable: false }, 
                        view_dimension: wgpu::TextureViewDimension::D2, 
                        multisampled: false 
                    },
                    count: None,
                },
                // Output Texture (Current Frame)
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::StorageTexture { 
                        access: wgpu::StorageTextureAccess::WriteOnly, 
                        format: wgpu::TextureFormat::Rgba8Unorm, 
                        view_dimension: wgpu::TextureViewDimension::D2 
                    },
                    count: None,
                },
            ],
        });

        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });

        let pipeline = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline"),
            layout: Some(&pipeline_layout),
            module: &shader,
            entry_point: "main",
            compilation_options: wgpu::PipelineCompilationOptions::default(), 
        });

        let landmarks = vec![
            Landmark { position: [0.0, 0.5], observed_dist: 0.0, confidence: 1.0, phase_offset: 0.0 },
            Landmark { position: [0.5, -0.5], observed_dist: 0.0, confidence: 1.0, phase_offset: 0.0 },
            Landmark { position: [-0.5, -0.5], observed_dist: 0.0, confidence: 1.0, phase_offset: 0.0 },
        ];

        Ok(Self {
            device,
            queue,
            surface,
            config,
            pipeline,
            bind_group_layout,
            texture_a,
            texture_a_view,
            texture_b,
            texture_b_view,
            uniform_buffer,
            landmark_buffer,
            start_time: js_sys::Date::now(),
            frame_count: 0,
            landmarks,
            camera_pos: [0.0, 0.0],
            width,
            height,
        })
    }

    pub fn update(&mut self) {
        let now = js_sys::Date::now();
        let t = (now - self.start_time) / 1000.0;
        
        self.camera_pos = [
            (t * 0.5).sin() as f32 * 0.5,
            (t * 0.3).cos() as f32 * 0.5
        ];

        for lm in &mut self.landmarks {
            let dx = lm.position[0] - self.camera_pos[0];
            let dy = lm.position[1] - self.camera_pos[1];
            lm.observed_dist = (dx*dx + dy*dy).sqrt();
            lm.phase_offset = (t as f32 * 2.0).sin() * 0.5;
        }

        self.queue.write_buffer(&self.landmark_buffer, 0, bytemuck::cast_slice(&self.landmarks));

        let uniforms = Uniforms {
            resolution: [self.width as f32, self.height as f32],
            time: t as f32,
            wave_number: 80.0,
            decay_factor: 5.0,
            feedback_strength: 0.90,
            num_landmarks: self.landmarks.len() as u32,
            _pad: 0,
            camera_pos: self.camera_pos,
        };
        self.queue.write_buffer(&self.uniform_buffer, 0, bytemuck::bytes_of(&uniforms));
    }

    pub fn render(&mut self) {
        let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

        let (input_view, output_view, source_tex) = if self.frame_count % 2 == 0 {
            (&self.texture_a_view, &self.texture_b_view, &self.texture_b)
        } else {
            (&self.texture_b_view, &self.texture_a_view, &self.texture_a)
        };

        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Frame BindGroup"),
            layout: &self.bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry { binding: 0, resource: self.uniform_buffer.as_entire_binding() },
                wgpu::BindGroupEntry { binding: 1, resource: self.landmark_buffer.as_entire_binding() },
                wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(input_view) },
                wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::TextureView(output_view) },
            ],
        });

        {
            let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor { label: None, timestamp_writes: None });
            cpass.set_pipeline(&self.pipeline);
            cpass.set_bind_group(0, &bind_group, &[]);
            cpass.dispatch_workgroups((self.width + 15) / 16, (self.height + 15) / 16, 1);
        }

        if let Some(surface_texture) = self.get_current_texture() {
            let _surface_view = surface_texture.texture.create_view(&wgpu::TextureViewDescriptor::default());
            
            encoder.copy_texture_to_texture(
                wgpu::ImageCopyTexture { texture: source_tex, mip_level: 0, origin: wgpu::Origin3d::ZERO, aspect: wgpu::TextureAspect::All },
                wgpu::ImageCopyTexture { texture: &surface_texture.texture, mip_level: 0, origin: wgpu::Origin3d::ZERO, aspect: wgpu::TextureAspect::All },
                wgpu::Extent3d { width: self.width, height: self.height, depth_or_array_layers: 1 }
            );

            self.queue.submit(Some(encoder.finish()));
            surface_texture.present();
        } else {
            self.queue.submit(Some(encoder.finish()));
        }

        self.frame_count += 1;
    }

    fn get_current_texture(&self) -> Option<wgpu::SurfaceTexture> {
        match self.surface.get_current_texture() {
            Ok(texture) => Some(texture),
            Err(wgpu::SurfaceError::Lost) => {
                self.surface.configure(&self.device, &self.config);
                None
            },
            Err(_) => None,
        }
    }
}
</file>

</files>
